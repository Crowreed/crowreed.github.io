<!DOCTYPE html>

<html lang="fr">
    <head>
        <!-- metadata -->

        <meta charset="UTF-8">
        <meta name="robots" content="index, follow">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Troisième partie : Diagramme de Voronoï</title>

        <meta
            name="description"
            content=""
        >

        <meta
            name="keywords"
            content=""
        >
        
        <meta
            name="author"
            content="Lucas Petit"
        >

        <link rel="icon" href="/assets/img/logo/logo.ico" type="image/x-icon">
        
        <!-- for rendering latex -->

        <!-- CSS -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

        <!-- JS -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

        <!-- ALL STYLESHEET -->
 
        <link rel="stylesheet" href="/assets/css/main.css">
    </head>
    <body>
        <header id="main-header-hihi">
            <nav>
                <ul>
                    <li>
                        <a href="../">
                            <svg style="padding-right: 0.5rem" class="flip-horizontal icon backwardArrow" viewBox="0 0 24 24"> <path d="m12 4-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path> </svg>
                            Empilements compacts
                        </a>
                    </li>
                </ul>
            </nav>
        </header>
        
        <main>
            <div id="toc-container"></div>

            <div id="article">
                <h3>Troisième partie : Diagramme de Voronoï</h3>

                <div class="paragraph">
                    Le but de cette troisième partie est d'approximer le diagramme de Voronoï d'un ensemble de points donnés.
                    Afin d'illustrer par des exemples le lien entre l'empilement compact et la conjecture du nid d'abeille.
                    Ou encore du lien être les empilements et le pavage du plan.
                    Pour cela, nous avons implémenté un algorithme qui, pour un ensemble de points donnés, approximera son
                    diagramme de Voronoï. L'algorithme fonctionne sur le principe suivant : nous partons d'un ensemble de
                    points, et, pour chaque point, nous allons faire gonfler un disque centré en ce point. Si deux disques
                    se rencontrent, nous les feront s'écraser l'un contre l'autre. Voir le schéma suivant.                   
                </div>
  
                
                

                <div class="evolution-container">
                    <img src="0.png" class="evo-img active" alt="Étape 1">
                    <img src="50.png" class="evo-img" alt="Étape 2">
                    <img src="100.png" class="evo-img" alt="Étape 3">
                    <img src="150.png" class="evo-img" alt="">
                    <img src="200.png" class="evo-img" alt="">
                    <img src="350.png" class="evo-img" alt="">
                    <img src="450.png" class="evo-img" alt="">

                    <button class="nav-btn prev" onclick="changeSlide(-1)">&#10094;</button>
                    <button class="nav-btn nextd" onclick="changeSlide(1)">&#10095;</button> 
                    <div class="counter">1 / 7</div>
                </div>

                
                <figure>
                    
                    
                    <figcaption>Étapes de l'algorithme</figcaption>
                </figure>

                <div class="paragraph">
                        On comprend bien que chaque zone colorée contient désormais l'ensemble des points qui sont les
                        plus proches du point d'origine de cette zone. En faisant gonfler les cercles et en les empêchant
                        de se superposer, les points de la couleur du disque gonflé seront les plus proches du centre de
                        ce disque (car la boule unité de la norme euclidienne est un cercle). On comprend bien que dès
                        qu'un point blanc sera atteint par un disque D, il sera plus proche du centre D que des centres voisins.
                         %plus introduire ce qu'est D et le point blanc ? 
                </div>
                
                <div class="paragraph">
                    %choisir un et bien l'expliquer, mettre le reste en annexe ?
                    Nous allons maintenant présenter les résultats des diagrammes obtenus, ils sont surtout intéressant
                    visuellement. Ils permettent de conforter l'intuition que nous avons sur le sujet global des empilements
                    compacts liés à l'aspect du pavage du plan. Pour illustrer l'empilement compact, nous allons voir
                    l'exemple des hexagones. On peut voir les hexagones se tracer distinctement à partir de la troisième
                    étape, et finir avec un empilement compact d'hexagones.            
                </div>
                
                <div class="evolution-container">
                    <img src="hexa_0.png" class="evo-img active" alt="Étape 1">
                    <img src="hexa_1.png" class="evo-img" alt="Étape 2">
                    <img src="hexa_2.png" class="evo-img" alt="Étape 3">
                    <img src="hexa_3.png" class="evo-img" alt="">

                    <button class="nav-btn prev" onclick="changeSlide(-1)">&#10094;</button> <button class="nav-btn nextd" onclick="changeSlide(1)">&#10095;</button>  <div class="counter">1 / 7</div>
                </div>
                <figure>
               
                    
                    
                    <figcaption>Diagramme de Voronoï des centres des disques de l'empilement hexagonal</figcaption>
                </figure>
                
                <div class="paragraph">
                    Il est cependant possible de paver l'espace avec d'autres formes géométriques grâce à cet algorithme.
                    Par exemple, faire des altérations compacte du graphe, ou même simplement paver l'espace avec des carrés.
                    \cite{Voronoi}
                </div>
            </div>
        </main>

        <footer id="main-footer"></footer>
        <script>
            // On sélectionne TOUS les conteneurs de carrousel présents sur la page
const carousels = document.querySelectorAll(".evolution-container");

// On configure chaque carrousel un par un
carousels.forEach(carousel => {
    
    // 1. Pour CE carrousel, on récupère ses propres éléments
    const slides = carousel.querySelectorAll(".evo-img");
    const prevBtn = carousel.querySelector(".prev");
    const nextBtn = carousel.querySelector(".nextd");
    const counter = carousel.querySelector(".counter");
    
    let currentIndex = 0; // Chaque carrousel a son propre index qui commence à 0

    // Fonction interne pour mettre à jour l'image
    const updateSlide = (index) => {
        // On cache tout
        slides.forEach(slide => slide.classList.remove("active"));
        
        // Gestion de la boucle (fin -> début ou début -> fin)
        if (index >= slides.length) currentIndex = 0;
        else if (index < 0) currentIndex = slides.length - 1;
        else currentIndex = index;

        // On affiche la bonne image
        slides[currentIndex].classList.add("active");

        
        if (counter) {
            counter.textContent = `${currentIndex + 1} / ${slides.length}`;
        }
    
    };

    // 2. On écoute les clics sur les boutons DE CE carrousel uniquement
    if(nextBtn) {
        nextBtn.addEventListener("click", () => {
            updateSlide(currentIndex + 1);
        });
    }

    if(prevBtn) {
        prevBtn.addEventListener("click", () => {
            updateSlide(currentIndex - 1);
        });

        
    }
});
        </script>
        
        <script type="module" src="/assets/js/main.js"></script>
    </body>
</html>